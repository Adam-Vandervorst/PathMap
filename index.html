<!doctype html>
<html lang="en-US">
<head>
    <meta charset="utf-8" />
    <title>hello-wasm example</title>
</head>
<body>
<div>
    active read zipper: <div id="active" style="display: inline">active</div><br>
    read zipper location: <div id="path" style="display: inline">path</div><br>
    direct children: <div id="children" style="display: inline">children</div><br>
    compound action: <div id="partial" style="display: inline">partial</div><br>
</div>
<div id="help" style="display: block;">
    <table>
        <tr><td>Space</td><td>New reader at root</td></tr>
        <tr><td>Tab</td><td>Focus next reader</td></tr>
        <tr><td>Shift+Tab</td><td>Focus previous reader</td></tr>
        <tr><td>Page-Up</td><td>Put focused reader on top</td></tr>
        <tr><td>Page-Down</td><td>Put focused reader on bottom</td></tr>
        <tr><td>Shift+Tab</td><td>Focus previous reader</td></tr>
        <tr><td>Shift+R</td><td>Range of type u32 with start, stop, and step</td></tr>
        <tr><td>Z</td><td>Fork reader</td></tr>
        <tr><td>Shift+Z</td><td>Fork reader and prefix it with a path</td></tr>
        <tr><td>|</td><td>Union of the top two readers</td></tr>
        <tr><td>&</td><td>Intersection of the top two readers</td></tr>
        <tr><td>\</td><td>Subtract top reader from second reader</td></tr>
        <tr><td>/</td><td>Subtract second reader from top reader</td></tr>
        <tr><td><</td><td>Restrict top reader to second reader</td></tr>
        <tr><td>></td><td>Restrict second reader to top reader</td></tr>
        <tr><td>^</td><td>Decapitation of the top reader</td></tr>
        <tr><td>v</td><td>Head of the top reader</td></tr>
        <tr><td>X</td><td>Take the product of the second and top reader; QUADRATIC</td></tr>
        <tr><td>Shift+T</td><td>Transform the top reader according to a regex pattern and template</td></tr>
        <tr><td>W</td><td>Move reader to lower sibling byte</td></tr>
        <tr><td>S</td><td>Move reader to higher sibling byte</td></tr>
        <tr><td>A</td><td>Ascend reader one byte</td></tr>
        <tr><td>D</td><td>Descend reader to first child byte</td></tr>
        <tr><td>Shift+D</td><td>Descend reader to nth child byte</td></tr>
        <tr><td>F</td><td>Descend to first value</td></tr>
        <tr><td>Shift+F</td><td>Descend reader to a specific byte</td></tr>
        <tr><td>C</td><td>Put the direct reader position children to console</td></tr>
        <tr><td>N</td><td>Put the number of values under the reader position to console</td></tr>
        <tr><td>M</td><td>Put the submap under the reader position to console (and draw it)</td></tr>
        <tr><td>P</td><td>Put the path of the reader position to console</td></tr>
        <tr><td>B</td><td>Put the bounds of the submap under reader position to console</td></tr>
        <tr><td>I</td><td>Upload and deserialize a submap</td></tr>
        <tr><td>O</td><td>Serialize and download the submap under the reader position</td></tr>
        <tr><td>?</td><td>Show/hide these instructions</td></tr>
    </table>
</div>
<div id="board"></div>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script type="module">
    function download_bin(filename, array) {
        const blob = new Blob([array], { type: "application/octet-stream" });
        const url = URL.createObjectURL(blob);
        let element = document.createElement('a');
        element.setAttribute('href', url);
        element.setAttribute('download', filename);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
        URL.revokeObjectURL(url);
    }

    function upload_bin(func) {
        let element = document.createElement('input');
        element.setAttribute('type', 'file');
        element.addEventListener('change', evt => {
            let r = new FileReader();
            r.onload = e => func({name: element.value.match(/([^\\]+$)/g)[0], content: e.target.result})
            r.readAsArrayBuffer(evt.target.files[0]);
        }, false);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
    }

    function indented(data) {
        const format = d3.format(",");
        const nodeSize = 17;
        const root = d3.hierarchy(data)
            .eachBefore((i => d => { d.index = i++; d.p = d.p ? [d.data.name, ...d.p] : [];
                                     if (d.children) d.children.forEach(c => c.p = d.p) })(0))
            .eachAfter(d => { d.count = d.children ? d.children.reduceRight((x, y) => x + y.count, 0) : 1;
                               });
        const nodes = root.descendants();
        const width = window.innerWidth;
        const height = (nodes.length + 1) * nodeSize;

        const columns = [
            {
                label: "Count",
                value: d => d.count,
                format: (value, d) => d.children ? format(value) : "-",
                x: 280
            },
            {
                label: "Depth",
                value: d => d.depth,
                format: value => value,
                x: 340
            },
            {
                label: "UInt",
                value: d => d.p.length != 0 && d.p.length <= 8 ? new DataView(new Uint8Array(d.p.concat(new Array(8 - d.p.length))).buffer).getBigUint64(0, true) : "",
                format: value => value,
                x: 400
            },
            {
                label: "Chars",
                value: d => d.p.map(b => b < 127 && b > 33 ? String.fromCharCode(b) : "\\u{" + b.toString(16) + "}").join(""),
                format: value => value,
                x: 460
            }
        ];

        const svg = d3.create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [-nodeSize / 2, -nodeSize * 3 / 2, width, height])
            .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif; overflow: visible;");

        const link = svg.append("g")
            .attr("fill", "none")
            .attr("stroke", "#999")
            .selectAll()
            .data(root.links())
            .join("path")
            .attr("d", d => `
        M${d.source.depth * nodeSize},${d.source.index * nodeSize}
        V${d.target.index * nodeSize}
        h${nodeSize}
      `);

        const node = svg.append("g")
            .selectAll()
            .data(nodes)
            .join("g")
            .attr("transform", d => `translate(0,${d.index * nodeSize})`);

        node.append("circle")
            .attr("cx", d => d.depth * nodeSize)
            .attr("r", 2.5)
            .attr("fill", d => d.children ? null : "#999");

        node.append("text")
            .attr("dy", "0.32em")
            .attr("x", d => d.depth * nodeSize + 6)
            .text(d => d.data.name);

        node.append("title")
            .text(d => d.ancestors().reverse().map(d => d.data.name).join("/"));

        for (const {label, value, format, x} of columns) {
            svg.append("text")
                .attr("dy", "0.32em")
                .attr("y", -nodeSize)
                .attr("x", x)
                .attr("text-anchor", "end")
                .attr("font-weight", "bold")
                .text(label);

            node.append("text")
                .attr("dy", "0.32em")
                .attr("x", x)
                .attr("text-anchor", "start")
                .attr("fill", d => d.children ? null : "#555")
                .text(d => format(value(d), d));
        }

        return svg.node();
    }

    function pack(data, { // data is either tabular (array of objects) or hierarchy (nested objects)
        path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes
        id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)
        parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier
        children, // if hierarchical data, given a d in data, returns its children
        value, // given a node d, returns a quantitative value (for area encoding; null for count)
        sort = (a, b) => d3.descending(a.value, b.value), // how to sort nodes prior to layout
        label, // given a leaf node d, returns the display name
        title, // given a node d, returns its hover text
        link, // given a node d, its link (if any)
        linkTarget = "_blank", // the target attribute for links, if any
        width = window.innerWidth, // outer width, in pixels
        height = window.innerHeight, // outer height, in pixels
        margin = 1, // shorthand for margins
        marginTop = margin, // top margin, in pixels
        marginRight = margin, // right margin, in pixels
        marginBottom = margin, // bottom margin, in pixels
        marginLeft = margin, // left margin, in pixels
        padding = 3, // separation between circles
        fill = "#ddd", // fill for leaf circles
        fillOpacity, // fill opacity for leaf circles
        stroke = "#bbb", // stroke for internal circles
        strokeWidth, // stroke width for internal circles
        strokeOpacity, // stroke opacity for internal circles
    } = {}) {

        // If id and parentId options are specified, or the path option, use d3.stratify
        // to convert tabular data to a hierarchy; otherwise we assume that the data is
        // specified as an object {children} with nested objects (a.k.a. the “flare.json”
        // format), and use d3.hierarchy.
        const root = path != null ? d3.stratify().path(path)(data)
            : id != null || parentId != null ? d3.stratify().id(id).parentId(parentId)(data)
                : d3.hierarchy(data, children);

        // Compute the values of internal nodes by aggregating from the leaves.
        value == null ? root.count() : root.sum(d => Math.max(0, value(d)));

        // Compute labels and titles.
        const descendants = root.descendants();
        const leaves = descendants.filter(d => !d.children);
        leaves.forEach((d, i) => d.index = i);
        const L = label == null ? null : leaves.map(d => label(d.data, d));
        const T = title == null ? null : descendants.map(d => title(d.data, d));
        console.log(descendants);
        console.log(leaves);

        // Sort the leaves (typically by descending value for a pleasing layout).
        if (sort != null) root.sort(sort);

        // Compute the layout.
        d3.pack()
            .size([width - marginLeft - marginRight, height - marginTop - marginBottom])
            .padding(padding)
            (root);

        const svg = d3.create("svg")
            .attr("viewBox", [-marginLeft, -marginTop, width, height])
            .attr("width", width)
            .attr("height", height)
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10)
            .attr("text-anchor", "middle");

        const node = svg.selectAll("a")
            .data(descendants)
            .join("a")
            .attr("xlink:href", link == null ? null : (d, i) => link(d.data, d))
            .attr("target", link == null ? null : linkTarget)
            .attr("transform", d => `translate(${d.x},${d.y})`);

        node.append("circle")
            .attr("fill", d => d.children ? "#fff" : fill)
            .attr("fill-opacity", d => d.children ? null : fillOpacity)
            .attr("stroke", d => d.children ? stroke : null)
            .attr("stroke-width", d => d.children ? strokeWidth : null)
            .attr("stroke-opacity", d => d.children ? strokeOpacity : null)
            .attr("r", d => d.r);

        if (T) node.append("title").text((d, i) => T[i]);

        if (L) {
            // A unique identifier for clip paths (to avoid conflicts).
            const uid = `O-${Math.random().toString(16).slice(2)}`;

            const leaf = node
                .filter(d => !d.children && d.r > 10 && L[d.index] != null);

            leaf.append("clipPath")
                .attr("id", d => `${uid}-clip-${d.index}`)
                .append("circle")
                .attr("r", d => d.r);

            leaf.append("text")
                .attr("clip-path", d => `url(${new URL(`#${uid}-clip-${d.index}`, location)})`)
                .selectAll("tspan")
                .data(d => `${L[d.index]}`.split(/\n/g))
                .join("tspan")
                .attr("x", 0)
                .attr("y", (d, i, D) => `${(i - D.length / 2) + 0.85}em`)
                .attr("fill-opacity", (d, i, D) => i === D.length - 1 ? 0.7 : null)
                .text(d => d);
        }

        return svg.node();
    }

    function chart(data) {

        // Specify the charts’ dimensions. The height is variable, depending on the layout.
        const width = window.innerWidth;
        const marginTop = 10;
        const marginRight = 10;
        const marginBottom = 10;
        const marginLeft = 40;

        // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
        // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
        // “bottom”, in the data domain. The width of a column is based on the tree’s height.
        const root = d3.hierarchy(data);
        const dx = 10;
        const dy = (width - marginRight - marginLeft) / (1 + root.height);

        // Define the tree layout and the shape for links.
        const tree = d3.tree().nodeSize([dx, dy]);
        const diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);

        // Create the SVG container, a layer for the links and a layer for the nodes.
        const svg = d3.create("svg")
            .attr("width", width)
            .attr("height", dx)
            .attr("viewBox", [-marginLeft, -marginTop, width, dx])
            .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif; user-select: none;");

        const gLink = svg.append("g")
            .attr("fill", "none")
            .attr("stroke", "#555")
            .attr("stroke-opacity", 0.4)
            .attr("stroke-width", 1.5);

        const gNode = svg.append("g")
            .attr("cursor", "pointer")
            .attr("pointer-events", "all");

        function update(event, source) {
            const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
            const nodes = root.descendants().reverse();
            const links = root.links();

            // Compute the new tree layout.
            tree(root);

            let left = root;
            let right = root;
            root.eachBefore(node => {
                if (node.x < left.x) left = node;
                if (node.x > right.x) right = node;
            });

            const height = right.x - left.x + marginTop + marginBottom;

            const transition = svg.transition()
                .duration(duration)
                .attr("height", height)
                .attr("viewBox", [-marginLeft, left.x - marginTop, width, height])
                .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));

            // Update the nodes…
            const node = gNode.selectAll("g")
                .data(nodes, d => d.id);

            // Enter any new nodes at the parent's previous position.
            const nodeEnter = node.enter().append("g")
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .attr("fill-opacity", 0)
                .attr("stroke-opacity", 0)
                .on("click", (event, d) => {
                    d.children = d.children ? null : d._children;
                    update(event, d);
                });

            nodeEnter.append("circle")
                .attr("r", 2.5)
                .attr("fill", d => d._children ? "#555" : "#999")
                .attr("stroke-width", 10);

            nodeEnter.append("text")
                .attr("dy", "0.31em")
                .attr("x", d => d._children ? -6 : 6)
                .attr("text-anchor", d => d._children ? "end" : "start")
                .text(d => d.data.name)
                .attr("stroke-linejoin", "round")
                .attr("stroke-width", 3)
                .attr("stroke", "white")
                .attr("paint-order", "stroke");

            // Transition nodes to their new position.
            const nodeUpdate = node.merge(nodeEnter).transition(transition)
                .attr("transform", d => `translate(${d.y},${d.x})`)
                .attr("fill-opacity", 1)
                .attr("stroke-opacity", 1);

            // Transition exiting nodes to the parent's new position.
            const nodeExit = node.exit().transition(transition).remove()
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .attr("fill-opacity", 0)
                .attr("stroke-opacity", 0);

            // Update the links…
            const link = gLink.selectAll("path")
                .data(links, d => d.target.id);

            // Enter any new links at the parent's previous position.
            const linkEnter = link.enter().append("path")
                .attr("d", d => {
                    const o = {x: source.x0, y: source.y0};
                    return diagonal({source: o, target: o});
                });

            // Transition links to their new position.
            link.merge(linkEnter).transition(transition)
                .attr("d", diagonal);

            // Transition exiting nodes to the parent's new position.
            link.exit().transition(transition).remove()
                .attr("d", d => {
                    const o = {x: source.x, y: source.y};
                    return diagonal({source: o, target: o});
                });

            // Stash the old positions for transition.
            root.eachBefore(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }

        // Do the first update to the initial configuration of the tree — where a number of nodes
        // are open (arbitrarily selected as the root, plus nodes with 7 letters).
        root.x0 = dy / 2;
        root.y0 = 0;
        root.descendants().forEach((d, i) => {
            d.id = i;
            d._children = d.children;
            if (d.depth && d.data.name.length !== 7) d.children = null;
        });

        update(null, root);

        return svg.node();
    }

    function zoomable_pack(data) {

        // Specify the chart’s dimensions.
        const width = window.innerWidth;
        const height = window.innerHeight;
        const ratio = Math.min(width, height)/Math.max(width, height)

        // Create the color scale.
        const color = d3.scaleLinear()
            .domain([0, 5])
            .range(["hsl(152,80%,80%)", "hsl(228,30%,40%)"])
            .interpolate(d3.interpolateHcl);

        // Compute the layout.
        const pack = data => d3.pack()
            .size([width, height])
            .padding(3)
            (d3.hierarchy(data)
                .sum(d => 1) // d.value
                .sort((a, b) => b.name - a.name));
        const root = pack(data);

        // Create the SVG container.
        const svg = d3.create("svg")
            .attr("viewBox", `-${width / 2} -${height / 2} ${width} ${height}`)
            .attr("width", width)
            .attr("height", height)
            .attr("style", `max-width: 100%; height: auto; display: block; margin: 0 -14px; background: ${color(0)}; cursor: pointer;`);

        // Append the nodes.
        const node = svg.append("g")
            .selectAll("circle")
            .data(root.descendants().slice(1))
            .join("circle")
            .attr("fill", d => d.children ? color(d.depth) : "white")
            .attr("pointer-events", d => !d.children ? "none" : null)
            .on("mouseover", function() { d3.select(this).attr("stroke", "#000"); })
            .on("mouseout", function() { d3.select(this).attr("stroke", null); })
            .on("click", (event, d) => focus !== d && (zoom(event, d), event.stopPropagation()));

        // Append the text labels.
        const label = svg.append("g")
            .style("font", "46pt sans-serif")
            .attr("pointer-events", "none")
            .attr("text-anchor", "middle")
            .selectAll("text")
            .data(root.descendants())
            .join("text")
            .style("fill-opacity", d => d.parent === root ? 1 : 0)
            .style("display", d => d.parent === root ? "inline" : "none")
            // .style("font-size", d => `${46 - 10*d.depth} pt`)
            .text(d => d.data.name);

        // Create the zoom behavior and zoom immediately in to the initial focus node.
        svg.on("click", (event) => zoom(event, root));
        let focus = root;
        let view;
        zoomTo([focus.x, focus.y, focus.r * 2/ratio]);

        function zoomTo(v) {
            const k = width / v[2];
            view = v;

            label.attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`);
            node.attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`);
            node.attr("r", d => d.r * k);
        }

        function zoom(event, d) {
            const focus0 = focus;
            focus = d;

            const transition = svg.transition()
                .duration(event.altKey ? 7500 : 750)
                .tween("zoom", d => {
                    const i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2/ratio]);
                    return t => zoomTo(i(t));
                });

            label
                .filter(function(d) { return d.parent === focus || this.style.display === "inline"; })
                .transition(transition)
                .style("fill-opacity", d => d.parent === focus ? 1 : 0)
                .on("start", function(d) { if (d.parent === focus) this.style.display = "inline"; })
                .on("end", function(d) { if (d.parent !== focus) this.style.display = "none"; });
        }

        return svg.node();
    }

    function parseByte(s) {
        if (s.startsWith("0x")) { return parseInt(s.slice(2), 16) }
        else if (s.startsWith("0b")) { return parseInt(s.slice(2), 2) }
        else if (s.startsWith("'")) { return s.slice(1).charCodeAt(0) }
        else { return parseInt(s, 10) }
    }

    import init, { range_be_u32, object, contains, reader, children, to_next_val, descend_to, descend_indexed_byte, to_next_sibling_byte, to_prev_sibling_byte, ascend, path, exists, d3_hierarchy, val_count, make_map, fork_reader, union, intersection, restriction, subtraction, decapitation, head, serialize, deserialize, min_path, max_path, product, wrap, regex_transform, from_paths } from "./pkg/pathmap.js";
    init().then(() => {
        window.root_map = range_be_u32(50000, 100000, 74);
        window.doing_partial = false;
        window.draw_in_tab = false;
        window.display_mode = "decimal";
        window.path_seperator = " ";
        let readers = [];
        let active = 0;
        let partial = null;

        let display_path = (p, sep = window.path_seperator) => {
            switch (window.display_mode) {
                case "hex": return p.map(x => x.toString(16)).join(sep);
                case "binary": return p.map(x => x.toString(2)).join(sep);
                case "decimal": return p.map(x => x.toString()).join(sep);
                case "char": return p.map(x => String.fromCharCode(x)).join(sep);
            }
        }

        let draw = () => {
            let r = readers[active];
            document.getElementById("active").innerText = active.toString() + " (" + readers.length + " total) " + r.origin;
            document.getElementById("path").innerText = display_path(path(r)) + (exists(r) ? "" : " (outside)");
            document.getElementById("children").innerText = display_path(children(r), ",");
            document.getElementById("partial").innerText = partial != null ? partial.name + " " + partial.s : "none";
        }

        window.addEventListener("keydown", e => {
            if (e.altKey || e.ctrlKey) { partial = null; return; }
            // window.requestAnimationFrame(draw);
            if (e.key === "Escape") { partial = null; return; }
            if (partial != null) { if (!(partial.next(e))) { window.requestAnimationFrame(draw); return; } }

            let r = readers[active];
            let nr = null;
            switch (e.key) {
                case " ":
                    nr = reader(window.root_map);
                    nr.origin = "(root)";
                    readers.push(nr);
                    break;
                case "Tab":
                    if (e.shiftKey) { active = Math.max(active - 1, 0) }
                    else { active = Math.min(active + 1, readers.length - 1) }
                    // if (e.shiftKey) { active = (readers.length + (active - 1)) % readers.length }
                    // else { active = (active + 1) % readers.length }
                    break;
                case "PageUp":
                    readers.splice(active, 1);
                    readers.push(r);
                    break;
                case "PageDown":
                    readers.splice(active, 1);
                    readers.unshift(r);
                    break;
                case "Delete":
                    readers.splice(active, 1);
                    if (readers.length === 0) {
                        let nr = reader(window.root_map);
                        nr.origin = "(default)"
                        readers.push(nr);
                    } else {
                        active = Math.max(active - 1, 0);
                    }
                    break;
                case "R":
                    let [start, stop, step] = prompt("range(start,stop,step)").split(",");
                    nr = reader(range_be_u32(parseInt(start, 10), parseInt(stop, 10), parseInt(step, 10)));
                    nr.origin = `range(${start},${stop},${step})`;
                    readers.push(nr);
                    break;
                case "z":
                    nr = fork_reader(r);
                    nr.origin = `fork(${r.origin} @ ${display_path(path(r))})`;
                    readers.push(nr);
                    break;
                case "Z":
                    let seq = new Uint8Array(prompt("b1 b2 ... bn").split(" ").map(parseByte));
                    nr = reader(wrap(make_map(r), seq));
                    nr.origin = `wrap ${display_path(seq)} (${r.origin} @ ${display_path(path(r))})`;
                    readers.push(nr);
                    break;
                case "|":
                    console.assert(readers.length > 1);
                    nr = reader(union(make_map(readers[readers.length - 1]), make_map(readers[readers.length - 2])));
                    nr.origin = `union of (${readers[readers.length - 1].origin} @ ${display_path(path(readers[readers.length - 1]))}) and (${readers[readers.length - 2].origin} @ ${display_path(path(readers[readers.length - 2]))})`;
                    readers.push(nr);
                    break;
                case "&":
                    console.assert(readers.length > 1);
                    nr = reader(intersection(make_map(readers[readers.length - 1]), make_map(readers[readers.length - 2])));
                    nr.origin = `intersection of (${readers[readers.length - 1].origin} @ ${display_path(path(readers[readers.length - 1]))}) and (${readers[readers.length - 2].origin} @ ${display_path(path(readers[readers.length - 2]))})`;
                    readers.push(nr);
                    break;
                case "\\":
                    console.assert(readers.length > 1);
                    nr = reader(subtraction(make_map(readers[readers.length - 1]), make_map(readers[readers.length - 2])));
                    nr.origin = `subtraction of (${readers[readers.length - 1].origin} @ ${display_path(path(readers[readers.length - 1]))}) and (${readers[readers.length - 2].origin} @ ${display_path(path(readers[readers.length - 2]))})`;
                    readers.push(nr);
                    break;
                case "/":
                    console.assert(readers.length > 1);
                    nr = reader(subtraction(make_map(readers[readers.length - 2]), make_map(readers[readers.length - 2])));
                    nr.origin = `subtraction of (${readers[readers.length - 2].origin} @ ${display_path(path(readers[readers.length - 2]))}) and (${readers[readers.length - 1].origin} @ ${display_path(path(readers[readers.length - 1]))})`;
                    readers.push(nr);
                    break;
                case "<":
                    console.assert(readers.length > 1);
                    nr = reader(restriction(make_map(readers[readers.length - 1]), make_map(readers[readers.length - 2])));
                    nr.origin = `restriction of (${readers[readers.length - 1].origin} @ ${display_path(path(readers[readers.length - 1]))}) and (${readers[readers.length - 2].origin} @ ${display_path(path(readers[readers.length - 2]))})`;
                    readers.push(nr);
                    break;
                case ">":
                    console.assert(readers.length > 1);
                    nr = reader(restriction(make_map(readers[readers.length - 2]), make_map(readers[readers.length - 2])));
                    nr.origin = `restriction of (${readers[readers.length - 2].origin} @ ${display_path(path(readers[readers.length - 2]))}) and (${readers[readers.length - 1].origin} @ ${display_path(path(readers[readers.length - 1]))})`;
                    readers.push(nr);
                    break;
                case "^":
                    nr = reader(decapitation(make_map(readers[readers.length - 1]), 1));
                    nr.origin = `decapitation of (${readers[readers.length - 1].origin} @ ${display_path(path(readers[readers.length - 1]))})`
                    readers.push(nr);
                    break;
                case "v":
                    nr = reader(head(make_map(readers[readers.length - 1]), 1));
                    nr.origin = `head of (${readers[readers.length - 1].origin} @ ${display_path(path(readers[readers.length - 1]))})`
                    readers.push(nr);
                    break;
                case "x":
                    console.assert(readers.length > 1);
                    nr = reader(product(make_map(readers[readers.length - 2]), make_map(readers[readers.length - 1])));
                    nr.origin = `product of (${readers[readers.length - 2].origin} @ ${display_path(path(readers[readers.length - 2]))}) and (${readers[readers.length - 1].origin} @ ${display_path(path(readers[readers.length - 1]))})`;
                    readers.push(nr);
                    break;
                case "T":
                    let pattern = prompt("regex pattern");
                    let template = prompt("regex template");
                    nr = reader(regex_transform(make_map(r), pattern, template))
                    nr.origin = `transform ${pattern} => ${template} (${r.origin} @ ${display_path(path(r))})`;
                    readers.push(nr);
                    break;
                case "w":
                    to_prev_sibling_byte(r);
                    break;
                case "s":
                    to_next_sibling_byte(r);
                    break;
                case "a":
                    ascend(r, 1);
                    break;
                case "d":
                    descend_indexed_byte(r, 0);
                    break;
                case "D":
                    if (window.doing_partial) {
                        partial = {
                            name: "descend to nth byte",
                            s: "",
                            next: (e_) => {
                                switch (e_.key) {
                                    case "Enter":
                                        if (partial.s === "") { descend_indexed_byte(r, 0); }
                                        else { descend_indexed_byte(r, parseByte(partial.s)); }
                                        partial = null;
                                        break;
                                    case "0": partial.s += "0"; break;
                                    case "1": partial.s += "1"; break;
                                    case "2": partial.s += "2"; break;
                                    case "3": partial.s += "3"; break;
                                    case "4": partial.s += "4"; break;
                                    case "5": partial.s += "5"; break;
                                    case "6": partial.s += "6"; break;
                                    case "7": partial.s += "7"; break;
                                    case "8": partial.s += "8"; break;
                                    case "9": partial.s += "9"; break;
                                    default: partial = null;
                                }
                            }
                        }
                    } else {
                        let s = prompt("n");
                        if (s === "") { descend_indexed_byte(r, 0); }
                        else { descend_indexed_byte(r, parseByte(s)); }
                    }
                    break;
                case "f":
                    to_next_val(r);
                    break;
                case "F":
                    if (window.doing_partial) {
                        partial = {
                            name: "descend to specific byte",
                            s: "",
                            next: (e_) => {
                                switch (e_.key) {
                                    case "Enter":
                                        if (partial.s === "") { }
                                        else { descend_to(r, new Uint8Array([parseByte(partial.s)])); }
                                        partial = null;
                                        break;
                                    case "0": partial.s += "0"; break;
                                    case "1": partial.s += "1"; break;
                                    case "2": partial.s += "2"; break;
                                    case "3": partial.s += "3"; break;
                                    case "4": partial.s += "4"; break;
                                    case "5": partial.s += "5"; break;
                                    case "6": partial.s += "6"; break;
                                    case "7": partial.s += "7"; break;
                                    case "8": partial.s += "8"; break;
                                    case "9": partial.s += "9"; break;
                                    default: partial = null;
                                }
                            }
                        }
                    } else {
                        let s = prompt("b");
                        if (s === "") { }
                        else { descend_to(r, new Uint8Array([parseByte(s)])); }
                    }
                    break;
                case "c":
                    console.log("children:", children(r));
                    return;
                case "n":
                    console.log("values under position:", val_count(r));
                    return;
                case "m":
                    let m = make_map(r);
                    console.log("map under position:", object(m));
                    if (window.draw_in_tab) {
                        let tab = window.open("about:blank");
                        tab.onload = () => { tab.document.body.append(indented(d3_hierarchy(m))) };
                    } else {
                        if (document.getElementById("board").children.length === 0) { document.getElementById("board").append(indented(d3_hierarchy(m))); }
                        else { document.getElementById("board").replaceChild(indented(d3_hierarchy(m)), document.getElementById("board").firstChild); }
                    }
                    return;
                case "p":
                    console.log("reader located at:", path(r));
                    return;
                case "b":
                    console.log("submap bounds", min_path(r), max_path(r));
                    return;
                case "e":
                    let tab = window.open("about:blank");
                    let text_box = document.createElement("textarea", {name: "paths"});
                    text_box.style.fontSize = "22pt";
                    text_box.style.width = "100%";
                    text_box.style.height = "100%";
                    tab.onload = () => { tab.document.body.append(text_box) };
                    tab.onbeforeunload = () => {
                        let lines = text_box.value.split("\n");
                        let paths = lines.map(l => new Uint8Array(l.split(" ").map(parseByte)))
                        nr = reader(from_paths(paths));
                        nr.origin = `manual edit ${new Date().toLocaleTimeString()}`;
                        readers.push(nr);
                        draw()
                    }
                    return;
                case "i":
                    upload_bin(o => {
                        nr = reader(deserialize(new Uint8Array(o.content)));
                        nr.origin = `uploaded ${o.name}`;
                        readers.push(nr);
                        draw()
                    })
                    return;
                case "o":
                    download_bin("reader" + active + ".bin", serialize(make_map(r)));
                    return;
                case "?":
                    if (document.getElementById("help").style.display === "none") { document.getElementById("help").style.display = "block"; }
                    else { document.getElementById("help").style.display = "none"; }
                    break;
                default:
                    return;
            }

            window.requestAnimationFrame(draw);

            if (e.stopPropagation) {e.stopPropagation(); e.preventDefault()}
        });

        window.dispatchEvent(new KeyboardEvent("keydown", {key: " "}));
    });
</script>
</body>
</html>
