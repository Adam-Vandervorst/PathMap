<!doctype html>
<html lang="en-US">
<head>
    <meta charset="utf-8" />
    <title>hello-wasm example</title>
</head>
<body>
<div>
    <div id="active">active</div>
    reader path and children; partial action
    <div id="path">path</div>
    <div id="children">children</div>
    <div id="partial">partial</div>
</div>
<div id="board"></div>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script type="module">
    function indented(data) {
        const format = d3.format(",");
        const nodeSize = 17;
        const root = d3.hierarchy(data).eachBefore((i => d => d.index = i++)(0));
        const nodes = root.descendants();
        const width = window.innerWidth;
        const height = (nodes.length + 1) * nodeSize;

        const columns = [
            {
                label: "Size",
                value: d => d.value,
                format,
                x: 280
            },
            {
                label: "Count",
                value: d => d.children ? 0 : 1,
                format: (value, d) => d.children ? format(value) : "-",
                x: 340
            }
        ];

        const svg = d3.create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [-nodeSize / 2, -nodeSize * 3 / 2, width, height])
            .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif; overflow: visible;");

        const link = svg.append("g")
            .attr("fill", "none")
            .attr("stroke", "#999")
            .selectAll()
            .data(root.links())
            .join("path")
            .attr("d", d => `
        M${d.source.depth * nodeSize},${d.source.index * nodeSize}
        V${d.target.index * nodeSize}
        h${nodeSize}
      `);

        const node = svg.append("g")
            .selectAll()
            .data(nodes)
            .join("g")
            .attr("transform", d => `translate(0,${d.index * nodeSize})`);

        node.append("circle")
            .attr("cx", d => d.depth * nodeSize)
            .attr("r", 2.5)
            .attr("fill", d => d.children ? null : "#999");

        node.append("text")
            .attr("dy", "0.32em")
            .attr("x", d => d.depth * nodeSize + 6)
            .text(d => d.data.name);

        node.append("title")
            .text(d => d.ancestors().reverse().map(d => d.data.name).join("/"));

        for (const {label, value, format, x} of columns) {
            svg.append("text")
                .attr("dy", "0.32em")
                .attr("y", -nodeSize)
                .attr("x", x)
                .attr("text-anchor", "end")
                .attr("font-weight", "bold")
                .text(label);

            node.append("text")
                .attr("dy", "0.32em")
                .attr("x", x)
                .attr("text-anchor", "end")
                .attr("fill", d => d.children ? null : "#555")
                .data(root.copy().sum(value).descendants())
                .text(d => format(d.value, d));
        }

        return svg.node();
    }

    function pack(data, { // data is either tabular (array of objects) or hierarchy (nested objects)
        path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes
        id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)
        parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier
        children, // if hierarchical data, given a d in data, returns its children
        value, // given a node d, returns a quantitative value (for area encoding; null for count)
        sort = (a, b) => d3.descending(a.value, b.value), // how to sort nodes prior to layout
        label, // given a leaf node d, returns the display name
        title, // given a node d, returns its hover text
        link, // given a node d, its link (if any)
        linkTarget = "_blank", // the target attribute for links, if any
        width = window.innerWidth, // outer width, in pixels
        height = window.innerHeight, // outer height, in pixels
        margin = 1, // shorthand for margins
        marginTop = margin, // top margin, in pixels
        marginRight = margin, // right margin, in pixels
        marginBottom = margin, // bottom margin, in pixels
        marginLeft = margin, // left margin, in pixels
        padding = 3, // separation between circles
        fill = "#ddd", // fill for leaf circles
        fillOpacity, // fill opacity for leaf circles
        stroke = "#bbb", // stroke for internal circles
        strokeWidth, // stroke width for internal circles
        strokeOpacity, // stroke opacity for internal circles
    } = {}) {

        // If id and parentId options are specified, or the path option, use d3.stratify
        // to convert tabular data to a hierarchy; otherwise we assume that the data is
        // specified as an object {children} with nested objects (a.k.a. the “flare.json”
        // format), and use d3.hierarchy.
        const root = path != null ? d3.stratify().path(path)(data)
            : id != null || parentId != null ? d3.stratify().id(id).parentId(parentId)(data)
                : d3.hierarchy(data, children);

        // Compute the values of internal nodes by aggregating from the leaves.
        value == null ? root.count() : root.sum(d => Math.max(0, value(d)));

        // Compute labels and titles.
        const descendants = root.descendants();
        const leaves = descendants.filter(d => !d.children);
        leaves.forEach((d, i) => d.index = i);
        const L = label == null ? null : leaves.map(d => label(d.data, d));
        const T = title == null ? null : descendants.map(d => title(d.data, d));
        console.log(descendants);
        console.log(leaves);

        // Sort the leaves (typically by descending value for a pleasing layout).
        if (sort != null) root.sort(sort);

        // Compute the layout.
        d3.pack()
            .size([width - marginLeft - marginRight, height - marginTop - marginBottom])
            .padding(padding)
            (root);

        const svg = d3.create("svg")
            .attr("viewBox", [-marginLeft, -marginTop, width, height])
            .attr("width", width)
            .attr("height", height)
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10)
            .attr("text-anchor", "middle");

        const node = svg.selectAll("a")
            .data(descendants)
            .join("a")
            .attr("xlink:href", link == null ? null : (d, i) => link(d.data, d))
            .attr("target", link == null ? null : linkTarget)
            .attr("transform", d => `translate(${d.x},${d.y})`);

        node.append("circle")
            .attr("fill", d => d.children ? "#fff" : fill)
            .attr("fill-opacity", d => d.children ? null : fillOpacity)
            .attr("stroke", d => d.children ? stroke : null)
            .attr("stroke-width", d => d.children ? strokeWidth : null)
            .attr("stroke-opacity", d => d.children ? strokeOpacity : null)
            .attr("r", d => d.r);

        if (T) node.append("title").text((d, i) => T[i]);

        if (L) {
            // A unique identifier for clip paths (to avoid conflicts).
            const uid = `O-${Math.random().toString(16).slice(2)}`;

            const leaf = node
                .filter(d => !d.children && d.r > 10 && L[d.index] != null);

            leaf.append("clipPath")
                .attr("id", d => `${uid}-clip-${d.index}`)
                .append("circle")
                .attr("r", d => d.r);

            leaf.append("text")
                .attr("clip-path", d => `url(${new URL(`#${uid}-clip-${d.index}`, location)})`)
                .selectAll("tspan")
                .data(d => `${L[d.index]}`.split(/\n/g))
                .join("tspan")
                .attr("x", 0)
                .attr("y", (d, i, D) => `${(i - D.length / 2) + 0.85}em`)
                .attr("fill-opacity", (d, i, D) => i === D.length - 1 ? 0.7 : null)
                .text(d => d);
        }

        return svg.node();
    }

    function chart(data) {

        // Specify the charts’ dimensions. The height is variable, depending on the layout.
        const width = window.innerWidth;
        const marginTop = 10;
        const marginRight = 10;
        const marginBottom = 10;
        const marginLeft = 40;

        // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
        // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
        // “bottom”, in the data domain. The width of a column is based on the tree’s height.
        const root = d3.hierarchy(data);
        const dx = 10;
        const dy = (width - marginRight - marginLeft) / (1 + root.height);

        // Define the tree layout and the shape for links.
        const tree = d3.tree().nodeSize([dx, dy]);
        const diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);

        // Create the SVG container, a layer for the links and a layer for the nodes.
        const svg = d3.create("svg")
            .attr("width", width)
            .attr("height", dx)
            .attr("viewBox", [-marginLeft, -marginTop, width, dx])
            .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif; user-select: none;");

        const gLink = svg.append("g")
            .attr("fill", "none")
            .attr("stroke", "#555")
            .attr("stroke-opacity", 0.4)
            .attr("stroke-width", 1.5);

        const gNode = svg.append("g")
            .attr("cursor", "pointer")
            .attr("pointer-events", "all");

        function update(event, source) {
            const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
            const nodes = root.descendants().reverse();
            const links = root.links();

            // Compute the new tree layout.
            tree(root);

            let left = root;
            let right = root;
            root.eachBefore(node => {
                if (node.x < left.x) left = node;
                if (node.x > right.x) right = node;
            });

            const height = right.x - left.x + marginTop + marginBottom;

            const transition = svg.transition()
                .duration(duration)
                .attr("height", height)
                .attr("viewBox", [-marginLeft, left.x - marginTop, width, height])
                .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));

            // Update the nodes…
            const node = gNode.selectAll("g")
                .data(nodes, d => d.id);

            // Enter any new nodes at the parent's previous position.
            const nodeEnter = node.enter().append("g")
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .attr("fill-opacity", 0)
                .attr("stroke-opacity", 0)
                .on("click", (event, d) => {
                    d.children = d.children ? null : d._children;
                    update(event, d);
                });

            nodeEnter.append("circle")
                .attr("r", 2.5)
                .attr("fill", d => d._children ? "#555" : "#999")
                .attr("stroke-width", 10);

            nodeEnter.append("text")
                .attr("dy", "0.31em")
                .attr("x", d => d._children ? -6 : 6)
                .attr("text-anchor", d => d._children ? "end" : "start")
                .text(d => d.data.name)
                .attr("stroke-linejoin", "round")
                .attr("stroke-width", 3)
                .attr("stroke", "white")
                .attr("paint-order", "stroke");

            // Transition nodes to their new position.
            const nodeUpdate = node.merge(nodeEnter).transition(transition)
                .attr("transform", d => `translate(${d.y},${d.x})`)
                .attr("fill-opacity", 1)
                .attr("stroke-opacity", 1);

            // Transition exiting nodes to the parent's new position.
            const nodeExit = node.exit().transition(transition).remove()
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .attr("fill-opacity", 0)
                .attr("stroke-opacity", 0);

            // Update the links…
            const link = gLink.selectAll("path")
                .data(links, d => d.target.id);

            // Enter any new links at the parent's previous position.
            const linkEnter = link.enter().append("path")
                .attr("d", d => {
                    const o = {x: source.x0, y: source.y0};
                    return diagonal({source: o, target: o});
                });

            // Transition links to their new position.
            link.merge(linkEnter).transition(transition)
                .attr("d", diagonal);

            // Transition exiting nodes to the parent's new position.
            link.exit().transition(transition).remove()
                .attr("d", d => {
                    const o = {x: source.x, y: source.y};
                    return diagonal({source: o, target: o});
                });

            // Stash the old positions for transition.
            root.eachBefore(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }

        // Do the first update to the initial configuration of the tree — where a number of nodes
        // are open (arbitrarily selected as the root, plus nodes with 7 letters).
        root.x0 = dy / 2;
        root.y0 = 0;
        root.descendants().forEach((d, i) => {
            d.id = i;
            d._children = d.children;
            if (d.depth && d.data.name.length !== 7) d.children = null;
        });

        update(null, root);

        return svg.node();
    }

    function zoomable_pack(data) {

        // Specify the chart’s dimensions.
        const width = window.innerWidth;
        const height = window.innerHeight;
        const ratio = Math.min(width, height)/Math.max(width, height)

        // Create the color scale.
        const color = d3.scaleLinear()
            .domain([0, 5])
            .range(["hsl(152,80%,80%)", "hsl(228,30%,40%)"])
            .interpolate(d3.interpolateHcl);

        // Compute the layout.
        const pack = data => d3.pack()
            .size([width, height])
            .padding(3)
            (d3.hierarchy(data)
                .sum(d => 1) // d.value
                .sort((a, b) => b.name - a.name));
        const root = pack(data);

        // Create the SVG container.
        const svg = d3.create("svg")
            .attr("viewBox", `-${width / 2} -${height / 2} ${width} ${height}`)
            .attr("width", width)
            .attr("height", height)
            .attr("style", `max-width: 100%; height: auto; display: block; margin: 0 -14px; background: ${color(0)}; cursor: pointer;`);

        // Append the nodes.
        const node = svg.append("g")
            .selectAll("circle")
            .data(root.descendants().slice(1))
            .join("circle")
            .attr("fill", d => d.children ? color(d.depth) : "white")
            .attr("pointer-events", d => !d.children ? "none" : null)
            .on("mouseover", function() { d3.select(this).attr("stroke", "#000"); })
            .on("mouseout", function() { d3.select(this).attr("stroke", null); })
            .on("click", (event, d) => focus !== d && (zoom(event, d), event.stopPropagation()));

        // Append the text labels.
        const label = svg.append("g")
            .style("font", "46pt sans-serif")
            .attr("pointer-events", "none")
            .attr("text-anchor", "middle")
            .selectAll("text")
            .data(root.descendants())
            .join("text")
            .style("fill-opacity", d => d.parent === root ? 1 : 0)
            .style("display", d => d.parent === root ? "inline" : "none")
            // .style("font-size", d => `${46 - 10*d.depth} pt`)
            .text(d => d.data.name);

        // Create the zoom behavior and zoom immediately in to the initial focus node.
        svg.on("click", (event) => zoom(event, root));
        let focus = root;
        let view;
        zoomTo([focus.x, focus.y, focus.r * 2/ratio]);

        function zoomTo(v) {
            const k = width / v[2];
            view = v;

            label.attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`);
            node.attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`);
            node.attr("r", d => d.r * k);
        }

        function zoom(event, d) {
            const focus0 = focus;
            focus = d;

            const transition = svg.transition()
                .duration(event.altKey ? 7500 : 750)
                .tween("zoom", d => {
                    const i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2/ratio]);
                    return t => zoomTo(i(t));
                });

            label
                .filter(function(d) { return d.parent === focus || this.style.display === "inline"; })
                .transition(transition)
                .style("fill-opacity", d => d.parent === focus ? 1 : 0)
                .on("start", function(d) { if (d.parent === focus) this.style.display = "inline"; })
                .on("end", function(d) { if (d.parent !== focus) this.style.display = "none"; });
        }

        return svg.node();
    }

    import init, { range_be_u32, object, contains, reader, children, to_next_val, descend_to, descend_indexed_byte, to_next_sibling_byte, to_prev_sibling_byte, ascend, path, exists, d3_hierarchy, val_count, make_map, fork_reader } from "./pkg/pathmap.js";
    init().then(() => {
        let readers = [];
        let active = 0;
        let partial = null;

        let draw = () => {
            let r = readers[active];
            document.getElementById("active").innerText = active.toString() + "/" + readers.length;
            document.getElementById("path").innerText = path(r).toString() + (exists(r) ? "" : " (outside)");
            document.getElementById("children").innerText = children(r).toString();
            document.getElementById("partial").innerText = partial != null ? partial.name + " " + partial.s : "none";
        }

        window.addEventListener("keydown", e => {
            draw()
            if (e.key === "Escape") { partial = null; return; }
            if (partial != null) { if (!(partial.next(e))) { draw(); return; } }

            let r = readers[active];
            switch (e.key) {
                case " ":
                    readers.push(reader(window.m));
                    break;
                case "Tab":
                    if (e.shiftKey) { active = Math.max(active - 1, 0) }
                    else { active = Math.min(active + 1, readers.length - 1) }
                    break;
                case "r":
                    readers.push(fork_reader(r));
                    break;
                case "w":
                    to_prev_sibling_byte(r);
                    break;
                case "s":
                    to_next_sibling_byte(r);
                    break;
                case "a":
                    ascend(r, 1);
                    break;
                case "d":
                    descend_indexed_byte(r, 0);
                    break;
                case "D":
                    partial = {
                        name: "descend to nth byte",
                        s: "",
                        next: (e_) => {
                            switch (e_.key) {
                                case "Enter":
                                    if (partial.s === "") { descend_indexed_byte(r, 0); }
                                    else { descend_indexed_byte(r, parseInt(partial.s, 10)); }
                                    partial = null;
                                    break;
                                case "0": partial.s += "0"; break;
                                case "1": partial.s += "1"; break;
                                case "2": partial.s += "2"; break;
                                case "3": partial.s += "3"; break;
                                case "4": partial.s += "4"; break;
                                case "5": partial.s += "5"; break;
                                case "6": partial.s += "6"; break;
                                case "7": partial.s += "7"; break;
                                case "8": partial.s += "8"; break;
                                case "9": partial.s += "9"; break;
                            }
                        }
                    }
                    break;
                case "f":
                    to_next_val(r);
                    break;
                case "F":
                    partial = {
                        name: "descend to specific byte",
                        s: "",
                        next: (e_) => {
                            switch (e_.key) {
                                case "Enter":
                                    if (partial.s === "") { }
                                    else { descend_to(r, new Uint8Array([parseInt(partial.s, 10)])); }
                                    partial = null;
                                    break;
                                case "0": partial.s += "0"; break;
                                case "1": partial.s += "1"; break;
                                case "2": partial.s += "2"; break;
                                case "3": partial.s += "3"; break;
                                case "4": partial.s += "4"; break;
                                case "5": partial.s += "5"; break;
                                case "6": partial.s += "6"; break;
                                case "7": partial.s += "7"; break;
                                case "8": partial.s += "8"; break;
                                case "9": partial.s += "9"; break;
                            }
                        }
                    }
                    break;
                case "c":
                    console.log("children:", children(r));
                    return;
                case "n":
                    console.log("values under position:", val_count(r));
                    return;
                case "m":
                    console.log("map under position:", object(make_map(r)));
                    if (document.getElementById("board").children.length === 0) { document.getElementById("board").append(indented(d3_hierarchy(make_map(r)))); }
                    else { document.getElementById("board").replaceChild(indented(d3_hierarchy(make_map(r))), document.getElementById("board").firstChild); }
                    return;
                case "p":
                    console.log("reader located at:", path(r));
                    return;
            }

            draw();

            if (e.stopPropagation) {e.stopPropagation(); e.preventDefault()}
        });

        window.m = range_be_u32(50000, 100000, 74);
        readers.push(reader(window.m));
        draw();

        // document.getElementById("board").append(chart(d3_hierarchy(m1)))
        // document.getElementById("board").append(indented(d3_hierarchy(m1)))
        // document.getElementById("board").append(zoomable_pack(d3_hierarchy(m1)))
        // document.getElementById("board").append(pack(d3_hierarchy(m1), {sort: (a, b) => d3.descending(a.name, b.name), label: (d, n) => d.name, title: (d, n) => d.name}))

        // let m1 = range_be_u32(0, 10, 3);
        // let m2 = range_be_u32(5, 15, 2);
        // console.assert(contains(m1, Uint8Array.of(0, 0, 0, 0)));
        // console.assert(!contains(m2, Uint8Array.of(0, 0, 0, 0)));
        // let r1 = reader(m1);
        // console.log(exists(r1), path(r1), children(r1));
        // descend_to(r1, Uint8Array.of(0, 0, 0));
        // console.log(exists(r1), path(r1), children(r1));
        // ascend(r1, 1);
        // console.log(exists(r1), path(r1), children(r1));
    });
</script>
</body>
</html>
